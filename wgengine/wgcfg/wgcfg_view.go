// Copyright (c) Tailscale Inc & AUTHORS
// SPDX-License-Identifier: BSD-3-Clause

// Code generated by tailscale/cmd/viewer; DO NOT EDIT.

package wgcfg

import (
	"encoding/json"
	"errors"
	"net/netip"

	"tailscale.com/tailcfg"
	"tailscale.com/types/key"
	"tailscale.com/types/logid"
	"tailscale.com/types/views"
)

//go:generate go run tailscale.com/cmd/cloner  -clonefunc=true -type=Config,Peer

// View returns a readonly view of Config.
func (p *Config) View() ConfigView {
	return ConfigView{ж: p}
}

// ConfigView provides a read-only view over Config.
//
// Its methods should only be called if `Valid()` returns true.
type ConfigView struct {
	// ж is the underlying mutable value, named with a hard-to-type
	// character that looks pointy like a pointer.
	// It is named distinctively to make you think of how dangerous it is to escape
	// to callers. You must not let callers be able to mutate it.
	ж *Config
}

// Valid reports whether underlying value is non-nil.
func (v ConfigView) Valid() bool { return v.ж != nil }

// AsStruct returns a clone of the underlying value which aliases no memory with
// the original.
func (v ConfigView) AsStruct() *Config {
	if v.ж == nil {
		return nil
	}
	return v.ж.Clone()
}

func (v ConfigView) MarshalJSON() ([]byte, error) { return json.Marshal(v.ж) }

func (v *ConfigView) UnmarshalJSON(b []byte) error {
	if v.ж != nil {
		return errors.New("already initialized")
	}
	if len(b) == 0 {
		return nil
	}
	var x Config
	if err := json.Unmarshal(b, &x); err != nil {
		return err
	}
	v.ж = &x
	return nil
}

func (v ConfigView) Name() string                         { return v.ж.Name }
func (v ConfigView) NodeID() tailcfg.StableNodeID         { return v.ж.NodeID }
func (v ConfigView) PrivateKey() key.NodePrivate          { return v.ж.PrivateKey }
func (v ConfigView) Addresses() views.Slice[netip.Prefix] { return views.SliceOf(v.ж.Addresses) }
func (v ConfigView) MTU() uint16                          { return v.ж.MTU }
func (v ConfigView) DNS() views.Slice[netip.Addr]         { return views.SliceOf(v.ж.DNS) }
func (v ConfigView) Peers() Peer                          { panic("unsupported") }
func (v ConfigView) NetworkLogging() struct {
	NodeID                  logid.PrivateID
	DomainID                logid.PrivateID
	ExitDestinationFlowLogs bool
} {
	return v.ж.NetworkLogging
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _ConfigViewNeedsRegeneration = Config(struct {
	Name           string
	NodeID         tailcfg.StableNodeID
	PrivateKey     key.NodePrivate
	Addresses      []netip.Prefix
	MTU            uint16
	DNS            []netip.Addr
	Peers          []Peer
	NetworkLogging struct {
		NodeID                  logid.PrivateID
		DomainID                logid.PrivateID
		ExitDestinationFlowLogs bool
	}
}{})

// View returns a readonly view of Peer.
func (p *Peer) View() PeerView {
	return PeerView{ж: p}
}

// PeerView provides a read-only view over Peer.
//
// Its methods should only be called if `Valid()` returns true.
type PeerView struct {
	// ж is the underlying mutable value, named with a hard-to-type
	// character that looks pointy like a pointer.
	// It is named distinctively to make you think of how dangerous it is to escape
	// to callers. You must not let callers be able to mutate it.
	ж *Peer
}

// Valid reports whether underlying value is non-nil.
func (v PeerView) Valid() bool { return v.ж != nil }

// AsStruct returns a clone of the underlying value which aliases no memory with
// the original.
func (v PeerView) AsStruct() *Peer {
	if v.ж == nil {
		return nil
	}
	return v.ж.Clone()
}

func (v PeerView) MarshalJSON() ([]byte, error) { return json.Marshal(v.ж) }

func (v *PeerView) UnmarshalJSON(b []byte) error {
	if v.ж != nil {
		return errors.New("already initialized")
	}
	if len(b) == 0 {
		return nil
	}
	var x Peer
	if err := json.Unmarshal(b, &x); err != nil {
		return err
	}
	v.ж = &x
	return nil
}

func (v PeerView) PublicKey() key.NodePublic             { return v.ж.PublicKey }
func (v PeerView) DiscoKey() key.DiscoPublic             { return v.ж.DiscoKey }
func (v PeerView) AllowedIPs() views.Slice[netip.Prefix] { return views.SliceOf(v.ж.AllowedIPs) }
func (v PeerView) V4MasqAddr() *netip.Addr {
	if v.ж.V4MasqAddr == nil {
		return nil
	}
	x := *v.ж.V4MasqAddr
	return &x
}

func (v PeerView) V6MasqAddr() *netip.Addr {
	if v.ж.V6MasqAddr == nil {
		return nil
	}
	x := *v.ж.V6MasqAddr
	return &x
}

func (v PeerView) PersistentKeepalive() uint16 { return v.ж.PersistentKeepalive }
func (v PeerView) WGEndpoint() key.NodePublic  { return v.ж.WGEndpoint }

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _PeerViewNeedsRegeneration = Peer(struct {
	PublicKey           key.NodePublic
	DiscoKey            key.DiscoPublic
	AllowedIPs          []netip.Prefix
	V4MasqAddr          *netip.Addr
	V6MasqAddr          *netip.Addr
	PersistentKeepalive uint16
	WGEndpoint          key.NodePublic
}{})
